{"ast":null,"code":"import { forwardRef, memo } from \"react\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useObserver } from \"./useObserver\";\nvar warnObserverOptionsDeprecated = true;\nvar hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nvar ReactForwardRefSymbol = hasSymbol ? Symbol.for(\"react.forward_ref\") : typeof forwardRef === \"function\" && forwardRef(function (props) {\n  return null;\n})[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol ? Symbol.for(\"react.memo\") : typeof memo === \"function\" && memo(function (props) {\n  return null;\n})[\"$$typeof\"];\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer(baseComponent,\n// TODO remove in next major\noptions) {\n  var _a;\n  if (process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options) {\n    warnObserverOptionsDeprecated = false;\n    console.warn(\"[mobx-react-lite] `observer(fn, { forwardRef: true })` is deprecated, use `observer(React.forwardRef(fn))`\");\n  }\n  if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n    throw new Error(\"[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.\");\n  }\n  // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n  if (isUsingStaticRendering()) {\n    return baseComponent;\n  }\n  var useForwardRef = (_a = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a !== void 0 ? _a : false;\n  var render = baseComponent;\n  var baseComponentName = baseComponent.displayName || baseComponent.name;\n  // If already wrapped with forwardRef, unwrap,\n  // so we can patch render and apply memo\n  if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n    useForwardRef = true;\n    render = baseComponent[\"render\"];\n    if (typeof render !== \"function\") {\n      throw new Error(\"[mobx-react-lite] `render` property of ForwardRef was not a function\");\n    }\n  }\n  var observerComponent = function (props, ref) {\n    return useObserver(function () {\n      return render(props, ref);\n    }, baseComponentName);\n  };\n  // Don't set `displayName` for anonymous components,\n  // so the `displayName` can be customized by user, see #3192.\n  if (baseComponentName !== \"\") {\n    ;\n    observerComponent.displayName = baseComponentName;\n  }\n  // Support legacy context: `contextTypes` must be applied before `memo`\n  if (baseComponent.contextTypes) {\n    ;\n    observerComponent.contextTypes = baseComponent.contextTypes;\n  }\n  if (useForwardRef) {\n    // `forwardRef` must be applied prior `memo`\n    // `forwardRef(observer(cmp))` throws:\n    // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n    observerComponent = forwardRef(observerComponent);\n  }\n  // memo; we are not interested in deep updates\n  // in props; we assume that if deep objects are changed,\n  // this is in observables, which would have been tracked anyway\n  observerComponent = memo(observerComponent);\n  copyStaticProperties(baseComponent, observerComponent);\n  if (\"production\" !== process.env.NODE_ENV) {\n    Object.defineProperty(observerComponent, \"contextTypes\", {\n      set: function () {\n        var _a;\n        throw new Error(\"[mobx-react-lite] `\".concat(this.displayName || ((_a = this.type) === null || _a === void 0 ? void 0 : _a.displayName) || \"Component\", \".contextTypes` must be set before applying `observer`.\"));\n      }\n    });\n  }\n  return observerComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n  $$typeof: true,\n  render: true,\n  compare: true,\n  type: true,\n  // Don't redefine `displayName`,\n  // it's defined as getter-setter pair on `memo` (see #3192).\n  displayName: true\n};\nfunction copyStaticProperties(base, target) {\n  Object.keys(base).forEach(function (key) {\n    if (!hoistBlackList[key]) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}","map":{"version":3,"names":["forwardRef","memo","isUsingStaticRendering","useObserver","warnObserverOptionsDeprecated","hasSymbol","Symbol","for","ReactForwardRefSymbol","props","ReactMemoSymbol","observer","baseComponent","options","process","env","NODE_ENV","console","warn","Error","useForwardRef","_a","render","baseComponentName","displayName","name","observerComponent","ref","contextTypes","copyStaticProperties","Object","defineProperty","set","concat","type","hoistBlackList","$$typeof","compare","base","target","keys","forEach","key","getOwnPropertyDescriptor"],"sources":["F:\\Study\\test_project\\LinkShortener\\frontend\\node_modules\\mobx-react-lite\\src\\observer.ts"],"sourcesContent":["import { forwardRef, memo } from \"react\"\n\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useObserver } from \"./useObserver\"\n\nlet warnObserverOptionsDeprecated = true\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof forwardRef === \"function\" && forwardRef((props: any) => null)[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof memo === \"function\" && memo((props: any) => null)[\"$$typeof\"]\n\nexport interface IObserverOptions {\n    readonly forwardRef?: boolean\n}\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefRenderFunction<TRef, P>,\n    options: IObserverOptions & { forwardRef: true }\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefExoticComponent<\n        React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n    >\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object>(\n    baseComponent: React.FunctionComponent<P>,\n    options?: IObserverOptions\n): React.FunctionComponent<P>\n\nexport function observer<\n    C extends React.FunctionComponent<any> | React.ForwardRefRenderFunction<any>,\n    Options extends IObserverOptions\n>(\n    baseComponent: C,\n    options?: Options\n): Options extends { forwardRef: true }\n    ? C extends React.ForwardRefRenderFunction<infer TRef, infer P>\n        ? C &\n              React.MemoExoticComponent<\n                  React.ForwardRefExoticComponent<\n                      React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n                  >\n              >\n        : never /* forwardRef set for a non forwarding component */\n    : C & { displayName: string }\n\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer<P extends object, TRef = {}>(\n    baseComponent:\n        | React.ForwardRefRenderFunction<TRef, P>\n        | React.FunctionComponent<P>\n        | React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>,\n    // TODO remove in next major\n    options?: IObserverOptions\n) {\n    if (process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options) {\n        warnObserverOptionsDeprecated = false\n        console.warn(\n            `[mobx-react-lite] \\`observer(fn, { forwardRef: true })\\` is deprecated, use \\`observer(React.forwardRef(fn))\\``\n        )\n    }\n\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            `[mobx-react-lite] You are trying to use \\`observer\\` on a function component wrapped in either another \\`observer\\` or \\`React.memo\\`. The observer already applies 'React.memo' for you.`\n        )\n    }\n\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent\n    }\n\n    let useForwardRef = options?.forwardRef ?? false\n    let render = baseComponent\n\n    const baseComponentName = baseComponent.displayName || baseComponent.name\n\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true\n        render = baseComponent[\"render\"]\n        if (typeof render !== \"function\") {\n            throw new Error(\n                `[mobx-react-lite] \\`render\\` property of ForwardRef was not a function`\n            )\n        }\n    }\n\n    let observerComponent = (props: any, ref: React.Ref<TRef>) => {\n        return useObserver(() => render(props, ref), baseComponentName)\n    }\n\n    // Don't set `displayName` for anonymous components,\n    // so the `displayName` can be customized by user, see #3192.\n    if (baseComponentName !== \"\") {\n        ;(observerComponent as React.FunctionComponent).displayName = baseComponentName\n    }\n\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if ((baseComponent as any).contextTypes) {\n        ;(observerComponent as React.FunctionComponent).contextTypes = (\n            baseComponent as any\n        ).contextTypes\n    }\n\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = forwardRef(observerComponent)\n    }\n\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = memo(observerComponent)\n\n    copyStaticProperties(baseComponent, observerComponent)\n\n    if (\"production\" !== process.env.NODE_ENV) {\n        Object.defineProperty(observerComponent, \"contextTypes\", {\n            set() {\n                throw new Error(\n                    `[mobx-react-lite] \\`${\n                        this.displayName || this.type?.displayName || \"Component\"\n                    }.contextTypes\\` must be set before applying \\`observer\\`.`\n                )\n            }\n        })\n    }\n\n    return observerComponent\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList: any = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n}\n\nfunction copyStaticProperties(base: any, target: any) {\n    Object.keys(base).forEach(key => {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}