{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\".concat(baseComponentName);\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */function () {\n  function ObjectToBeRetainedByReact() {}\n  return ObjectToBeRetainedByReact;\n}();\nfunction objectToBeRetainedByReactFactory() {\n  return new ObjectToBeRetainedByReact();\n}\nexport function useObserver(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n  var _a = __read(React.useState(objectToBeRetainedByReactFactory), 1),\n    objectRetainedByReact = _a[0];\n  // Force update, see #2982\n  var _b = __read(React.useState(), 2),\n    setState = _b[1];\n  var forceUpdate = function () {\n    return setState([]);\n  };\n  // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n  var admRef = React.useRef(null);\n  if (!admRef.current) {\n    // First render\n    admRef.current = {\n      reaction: null,\n      mounted: false,\n      changedBeforeMount: false\n    };\n  }\n  var adm = admRef.current;\n  if (!adm.reaction) {\n    // First render or component was not committed and reaction was disposed by registry\n    adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (adm.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.\n        adm.changedBeforeMount = true;\n      }\n    });\n    observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);\n  }\n  React.useDebugValue(adm.reaction, printDebugValue);\n  React.useEffect(function () {\n    observerFinalizationRegistry.unregister(adm);\n    adm.mounted = true;\n    if (adm.reaction) {\n      if (adm.changedBeforeMount) {\n        // Got a change before mount, force an update\n        adm.changedBeforeMount = false;\n        forceUpdate();\n      }\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This can be due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up\n      // Re-create the reaction\n      adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n        // We've definitely already been mounted at this point\n        forceUpdate();\n      });\n      forceUpdate();\n    }\n    return function () {\n      adm.reaction.dispose();\n      adm.reaction = null;\n      adm.mounted = false;\n      adm.changedBeforeMount = false;\n    };\n  }, []);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var rendering;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return rendering;\n}","map":{"version":3,"names":["Reaction","React","printDebugValue","observerFinalizationRegistry","isUsingStaticRendering","observerComponentNameFor","baseComponentName","concat","ObjectToBeRetainedByReact","objectToBeRetainedByReactFactory","useObserver","fn","_a","__read","useState","objectRetainedByReact","_b","setState","forceUpdate","admRef","useRef","current","reaction","mounted","changedBeforeMount","adm","register","useDebugValue","useEffect","unregister","dispose","rendering","exception","track","e"],"sources":["F:\\Study\\test_project\\LinkShortener\\frontend\\node_modules\\mobx-react-lite\\src\\useObserver.ts"],"sourcesContent":["import { Reaction } from \"mobx\"\nimport React from \"react\"\nimport { printDebugValue } from \"./utils/printDebugValue\"\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\n\nfunction observerComponentNameFor(baseComponentName: string) {\n    return `observer${baseComponentName}`\n}\n\ntype ObserverAdministration = {\n    /** The Reaction created during first render, which may be leaked */\n    reaction: Reaction | null\n\n    /**\n     * Whether the component has yet completed mounting (for us, whether\n     * its useEffect has run)\n     */\n    mounted: boolean\n\n    /**\n     * Whether the observables that the component is tracking changed between\n     * the first render and the first useEffect.\n     */\n    changedBeforeMount: boolean\n}\n\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nclass ObjectToBeRetainedByReact {}\n\nfunction objectToBeRetainedByReactFactory() {\n    return new ObjectToBeRetainedByReact()\n}\n\nexport function useObserver<T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    if (isUsingStaticRendering()) {\n        return fn()\n    }\n\n    const [objectRetainedByReact] = React.useState(objectToBeRetainedByReactFactory)\n    // Force update, see #2982\n    const [, setState] = React.useState()\n    const forceUpdate = () => setState([] as any)\n\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    const admRef = React.useRef<ObserverAdministration | null>(null)\n\n    if (!admRef.current) {\n        // First render\n        admRef.current = {\n            reaction: null,\n            mounted: false,\n            changedBeforeMount: false\n        }\n    }\n\n    const adm = admRef.current!\n\n    if (!adm.reaction) {\n        // First render or component was not committed and reaction was disposed by registry\n        adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (adm.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate()\n            } else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                adm.changedBeforeMount = true\n            }\n        })\n\n        observerFinalizationRegistry.register(objectRetainedByReact, adm, adm)\n    }\n\n    React.useDebugValue(adm.reaction, printDebugValue)\n\n    React.useEffect(() => {\n        observerFinalizationRegistry.unregister(adm)\n\n        adm.mounted = true\n\n        if (adm.reaction) {\n            if (adm.changedBeforeMount) {\n                // Got a change before mount, force an update\n                adm.changedBeforeMount = false\n                forceUpdate()\n            }\n        } else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n\n            // Re-create the reaction\n            adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), () => {\n                // We've definitely already been mounted at this point\n                forceUpdate()\n            })\n            forceUpdate()\n        }\n\n        return () => {\n            adm.reaction!.dispose()\n            adm.reaction = null\n            adm.mounted = false\n            adm.changedBeforeMount = false\n        }\n    }, [])\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let rendering!: T\n    let exception\n    adm.reaction.track(() => {\n        try {\n            rendering = fn()\n        } catch (e) {\n            exception = e\n        }\n    })\n\n    if (exception) {\n        throw exception // re-throw any exceptions caught during rendering\n    }\n\n    return rendering\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}