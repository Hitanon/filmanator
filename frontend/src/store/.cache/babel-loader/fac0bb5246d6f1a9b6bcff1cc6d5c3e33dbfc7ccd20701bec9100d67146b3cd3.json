{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"children\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disabledItemsFocusable\", \"disableSelection\", \"expanded\", \"id\", \"multiSelect\", \"onBlur\", \"onFocus\", \"onKeyDown\", \"onNodeFocus\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"];\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport { styled, useTheme, useThemeProps } from '@mui/material/styles';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport { useControlled, useForkRef, ownerDocument, unstable_useId as useId } from '@mui/material/utils';\nimport TreeViewContext from './TreeViewContext';\nimport { DescendantProvider } from './descendants';\nimport { getTreeViewUtilityClass } from './treeViewClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getTreeViewUtilityClass, classes);\n};\nconst TreeViewRoot = styled('ul', {\n  name: 'MuiTreeView',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})({\n  padding: 0,\n  margin: 0,\n  listStyle: 'none',\n  outline: 0\n});\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction noopSelection() {\n  return false;\n}\nconst defaultDefaultExpanded = [];\nconst defaultDefaultSelected = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiTreeView'\n  });\n  const {\n      children,\n      className,\n      defaultCollapseIcon,\n      defaultEndIcon,\n      defaultExpanded = defaultDefaultExpanded,\n      defaultExpandIcon,\n      defaultParentIcon,\n      defaultSelected = defaultDefaultSelected,\n      disabledItemsFocusable = false,\n      disableSelection = false,\n      expanded: expandedProp,\n      id: idProp,\n      multiSelect = false,\n      onBlur,\n      onFocus,\n      onKeyDown,\n      onNodeFocus,\n      onNodeSelect,\n      onNodeToggle,\n      selected: selectedProp\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const theme = useTheme();\n  const isRtl = theme.direction === 'rtl';\n  const ownerState = _extends({}, props, {\n    defaultExpanded,\n    defaultSelected,\n    disabledItemsFocusable,\n    disableSelection,\n    multiSelect\n  });\n  const classes = useUtilityClasses(ownerState);\n  const treeId = useId(idProp);\n  const treeRef = React.useRef(null);\n  const handleRef = useForkRef(treeRef, ref);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const [expanded, setExpandedState] = useControlled({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = useControlled({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n\n  /*\n   * Status Helpers\n   */\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isExpandable = React.useCallback(id => nodeMap.current[id] && nodeMap.current[id].expandable, []);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n  const isDisabled = React.useCallback(id => {\n    let node = nodeMap.current[id];\n\n    // This can be called before the node has been added to the node map.\n    if (!node) {\n      return false;\n    }\n    if (node.disabled) {\n      return true;\n    }\n    while (node.parentId != null) {\n      node = nodeMap.current[node.parentId];\n      if (node.disabled) {\n        return true;\n      }\n    }\n    return false;\n  }, []);\n  const isFocused = id => focusedNodeId === id;\n\n  /*\n   * Child Helpers\n   */\n\n  // Using Object.keys -> .map to mimic Object.values we should replace with Object.values() once we stop IE11 support.\n  const getChildrenIds = id => Object.keys(nodeMap.current).map(key => {\n    return nodeMap.current[key];\n  }).filter(node => node.parentId === id).sort((a, b) => a.index - b.index).map(child => child.id);\n  const getNavigableChildrenIds = id => {\n    let childrenIds = getChildrenIds(id);\n    if (!disabledItemsFocusable) {\n      childrenIds = childrenIds.filter(node => !isDisabled(node));\n    }\n    return childrenIds;\n  };\n\n  /*\n   * Node Helpers\n   */\n\n  const getNextNode = id => {\n    // If expanded get first child\n    if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n      return getNavigableChildrenIds(id)[0];\n    }\n    let node = nodeMap.current[id];\n    while (node != null) {\n      // Try to get next sibling\n      const siblings = getNavigableChildrenIds(node.parentId);\n      const nextSibling = siblings[siblings.indexOf(node.id) + 1];\n      if (nextSibling) {\n        return nextSibling;\n      }\n\n      // If the sibling does not exist, go up a level to the parent and try again.\n      node = nodeMap.current[node.parentId];\n    }\n    return null;\n  };\n  const getPreviousNode = id => {\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nodeIndex = siblings.indexOf(id);\n    if (nodeIndex === 0) {\n      return node.parentId;\n    }\n    let currentNode = siblings[nodeIndex - 1];\n    while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {\n      currentNode = getNavigableChildrenIds(currentNode).pop();\n    }\n    return currentNode;\n  };\n  const getLastNode = () => {\n    let lastNode = getNavigableChildrenIds(null).pop();\n    while (isExpanded(lastNode)) {\n      lastNode = getNavigableChildrenIds(lastNode).pop();\n    }\n    return lastNode;\n  };\n  const getFirstNode = () => getNavigableChildrenIds(null)[0];\n  const getParent = id => nodeMap.current[id].parentId;\n\n  /**\n   * This is used to determine the start and end of a selection range so\n   * we can get the nodes between the two border nodes.\n   *\n   * It finds the nodes' common ancestor using\n   * a naive implementation of a lowest common ancestor algorithm\n   * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n   * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n   * so we can compare their indexes to work out which node comes first in a depth first search.\n   * (https://en.wikipedia.org/wiki/Depth-first_search)\n   *\n   * Another way to put it is which node is shallower in a trÃ©maux tree\n   * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n   */\n  const findOrderInTremauxTree = (nodeAId, nodeBId) => {\n    if (nodeAId === nodeBId) {\n      return [nodeAId, nodeBId];\n    }\n    const nodeA = nodeMap.current[nodeAId];\n    const nodeB = nodeMap.current[nodeBId];\n    if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n      return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n    }\n    const aFamily = [nodeA.id];\n    const bFamily = [nodeB.id];\n    let aAncestor = nodeA.parentId;\n    let bAncestor = nodeB.parentId;\n    let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n    let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n    let continueA = true;\n    let continueB = true;\n    while (!bAncestorIsCommon && !aAncestorIsCommon) {\n      if (continueA) {\n        aFamily.push(aAncestor);\n        aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        continueA = aAncestor !== null;\n        if (!aAncestorIsCommon && continueA) {\n          aAncestor = nodeMap.current[aAncestor].parentId;\n        }\n      }\n      if (continueB && !aAncestorIsCommon) {\n        bFamily.push(bAncestor);\n        bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n        continueB = bAncestor !== null;\n        if (!bAncestorIsCommon && continueB) {\n          bAncestor = nodeMap.current[bAncestor].parentId;\n        }\n      }\n    }\n    const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n    const ancestorFamily = getChildrenIds(commonAncestor);\n    const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n    const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n    return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n  };\n  const getNodesInRange = (nodeA, nodeB) => {\n    const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n    const nodes = [first];\n    let current = first;\n    while (current !== last) {\n      current = getNextNode(current);\n      nodes.push(current);\n    }\n    return nodes;\n  };\n\n  /*\n   * Focus Helpers\n   */\n\n  const focus = (event, id) => {\n    if (id) {\n      setFocusedNodeId(id);\n      if (onNodeFocus) {\n        onNodeFocus(event, id);\n      }\n    }\n  };\n  const focusNextNode = (event, id) => focus(event, getNextNode(id));\n  const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n  const focusFirstNode = event => focus(event, getFirstNode());\n  const focusLastNode = event => focus(event, getLastNode());\n  const focusByFirstCharacter = (event, id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = [];\n    // This really only works since the ids are strings\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parentId ? isExpanded(map.parentId) : true;\n      const shouldBeSkipped = disabledItemsFocusable ? false : isDisabled(nodeId);\n      if (visible && !shouldBeSkipped) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    });\n\n    // Get start index for search based on position of currentItem\n    start = firstCharIds.indexOf(id) + 1;\n    if (start >= firstCharIds.length) {\n      start = 0;\n    }\n\n    // Check remaining slots in the menu\n    index = findNextFirstChar(firstChars, start, lowercaseChar);\n\n    // If not found in remaining slots, check from beginning\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    }\n\n    // If match was found...\n    if (index > -1) {\n      focus(event, firstCharIds[index]);\n    }\n  };\n\n  /*\n   * Expansion Helpers\n   */\n\n  const toggleExpansion = function (event) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : focusedNodeId;\n    let newExpanded;\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n    setExpandedState(newExpanded);\n  };\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const siblings = getChildrenIds(map.parentId);\n    const diff = siblings.filter(child => isExpandable(child) && !isExpanded(child));\n    const newExpanded = expanded.concat(diff);\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n\n  /*\n   * Selection Helpers\n   */\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n    if (!next || !current) {\n      return;\n    }\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n    setSelectedState(base);\n  };\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      end\n    } = nodes;\n    // If last selection was a range selection ignore nodes that were selected.\n    if (lastSelectionWasRange.current) {\n      base = base.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n    let range = getNodesInRange(start, end);\n    range = range.filter(node => !isDisabled(node));\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n    setSelectedState(newSelected);\n  };\n  const handleMultipleSelect = (event, value) => {\n    let newSelected;\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n    setSelectedState(newSelected);\n  };\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n    setSelectedState(newSelected);\n  };\n  const selectNode = function (event, id) {\n    let multiple = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n    return false;\n  };\n  const selectRange = function (event, nodes) {\n    let stacked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else if (start != null && end != null) {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n    lastSelectionWasRange.current = true;\n  };\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n  const selectNextNode = (event, id) => {\n    if (!isDisabled(getNextNode(id))) {\n      selectRange(event, {\n        end: getNextNode(id),\n        current: id\n      }, true);\n    }\n  };\n  const selectPreviousNode = (event, id) => {\n    if (!isDisabled(getPreviousNode(id))) {\n      selectRange(event, {\n        end: getPreviousNode(id),\n        current: id\n      }, true);\n    }\n  };\n  const selectAllNodes = event => {\n    selectRange(event, {\n      start: getFirstNode(),\n      end: getLastNode()\n    });\n  };\n\n  /*\n   * Mapping Helpers\n   */\n  const registerNode = React.useCallback(node => {\n    const {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    } = node;\n    nodeMap.current[id] = {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    };\n  }, []);\n  const unregisterNode = React.useCallback(id => {\n    const newMap = _extends({}, nodeMap.current);\n    delete newMap[id];\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id && treeRef.current === ownerDocument(treeRef.current).activeElement) {\n        return getChildrenIds(null)[0];\n      }\n      return oldFocusedNodeId;\n    });\n  }, []);\n  const mapFirstChar = React.useCallback((id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  }, []);\n  const unMapFirstChar = React.useCallback(id => {\n    const newMap = _extends({}, firstCharMap.current);\n    delete newMap[id];\n    firstCharMap.current = newMap;\n  }, []);\n\n  /**\n   * Event handlers and Navigation\n   */\n\n  const handleNextArrow = event => {\n    if (isExpandable(focusedNodeId)) {\n      if (isExpanded(focusedNodeId)) {\n        focusNextNode(event, focusedNodeId);\n      } else if (!isDisabled(focusedNodeId)) {\n        toggleExpansion(event);\n      }\n    }\n    return true;\n  };\n  const handlePreviousArrow = event => {\n    if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n      toggleExpansion(event, focusedNodeId);\n      return true;\n    }\n    const parent = getParent(focusedNodeId);\n    if (parent) {\n      focus(event, parent);\n      return true;\n    }\n    return false;\n  };\n  const handleKeyDown = event => {\n    let flag = false;\n    const key = event.key;\n\n    // If the tree is empty there will be no focused node\n    if (event.altKey || event.currentTarget !== event.target || !focusedNodeId) {\n      return;\n    }\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n    switch (key) {\n      case ' ':\n        if (!disableSelection && !isDisabled(focusedNodeId)) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, {\n              end: focusedNodeId\n            });\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n        event.stopPropagation();\n        break;\n      case 'Enter':\n        if (!isDisabled(focusedNodeId)) {\n          if (isExpandable(focusedNodeId)) {\n            toggleExpansion(event);\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n        event.stopPropagation();\n        break;\n      case 'ArrowDown':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectNextNode(event, focusedNodeId);\n        }\n        focusNextNode(event, focusedNodeId);\n        flag = true;\n        break;\n      case 'ArrowUp':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectPreviousNode(event, focusedNodeId);\n        }\n        focusPreviousNode(event, focusedNodeId);\n        flag = true;\n        break;\n      case 'ArrowRight':\n        if (isRtl) {\n          flag = handlePreviousArrow(event);\n        } else {\n          flag = handleNextArrow(event);\n        }\n        break;\n      case 'ArrowLeft':\n        if (isRtl) {\n          flag = handleNextArrow(event);\n        } else {\n          flag = handlePreviousArrow(event);\n        }\n        break;\n      case 'Home':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToFirst(event, focusedNodeId);\n        }\n        focusFirstNode(event);\n        flag = true;\n        break;\n      case 'End':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToLast(event, focusedNodeId);\n        }\n        focusLastNode(event);\n        flag = true;\n        break;\n      default:\n        if (key === '*') {\n          expandAllSiblings(event, focusedNodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === 'a' && !disableSelection) {\n          selectAllNodes(event);\n          flag = true;\n        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {\n          focusByFirstCharacter(event, focusedNodeId, key);\n          flag = true;\n        }\n    }\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n  const handleFocus = event => {\n    // if the event bubbled (which is React specific) we don't want to steal focus\n    if (event.target === event.currentTarget) {\n      const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n      focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n    }\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n  const handleBlur = event => {\n    setFocusedNodeId(null);\n    if (onBlur) {\n      onBlur(event);\n    }\n  };\n  const activeDescendant = nodeMap.current[focusedNodeId] ? nodeMap.current[focusedNodeId].idAttribute : null;\n  return /*#__PURE__*/_jsx(TreeViewContext.Provider, {\n    // TODO: fix this lint error\n    // eslint-disable-next-line react/jsx-no-constructed-context-values\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      toggleExpansion,\n      isExpanded,\n      isExpandable,\n      isFocused,\n      isSelected,\n      isDisabled,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      multiSelect,\n      disabledItemsFocusable,\n      mapFirstChar,\n      unMapFirstChar,\n      registerNode,\n      unregisterNode,\n      treeId\n    },\n    children: /*#__PURE__*/_jsx(DescendantProvider, {\n      children: /*#__PURE__*/_jsx(TreeViewRoot, _extends({\n        role: \"tree\",\n        id: treeId,\n        \"aria-activedescendant\": activeDescendant,\n        \"aria-multiselectable\": multiSelect,\n        className: clsx(classes.root, className),\n        ref: handleRef,\n        tabIndex: 0,\n        onKeyDown: handleKeyDown,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        ownerState: ownerState\n      }, other, {\n        children: children\n      }))\n    })\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? TreeView.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The default icon used to collapse the node.\n   */\n  defaultCollapseIcon: PropTypes.node,\n  /**\n   * The default icon displayed next to a end node. This is applied to all\n   * tree nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultEndIcon: PropTypes.node,\n  /**\n   * Expanded node ids. (Uncontrolled)\n   * @default []\n   */\n  defaultExpanded: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * The default icon used to expand the node.\n   */\n  defaultExpandIcon: PropTypes.node,\n  /**\n   * The default icon displayed next to a parent node. This is applied to all\n   * parent nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultParentIcon: PropTypes.node,\n  /**\n   * Selected node ids. (Uncontrolled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: PropTypes.bool,\n  /**\n   * If `true` selection is disabled.\n   * @default false\n   */\n  disableSelection: PropTypes.bool,\n  /**\n   * Expanded node ids. (Controlled)\n   */\n  expanded: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: PropTypes.string,\n  /**\n   * If true `ctrl` and `shift` will trigger multiselect.\n   * @default false\n   */\n  multiSelect: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onFocus: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n  /**\n   * Callback fired when tree items are focused.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback **Warning**: This is a generic event not a focus event.\n   * @param {string} value of the focused node.\n   */\n  onNodeFocus: PropTypes.func,\n  /**\n   * Callback fired when tree items are selected/unselected.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback\n   * @param {string[] | string} nodeIds Ids of the selected nodes. When `multiSelect` is true\n   * this is an array of strings; when false (default) a string.\n   */\n  onNodeSelect: PropTypes.func,\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes.\n   */\n  onNodeToggle: PropTypes.func,\n  /**\n   * Selected node ids. (Controlled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default TreeView;","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","_excluded","React","clsx","PropTypes","styled","useTheme","useThemeProps","unstable_composeClasses","composeClasses","useControlled","useForkRef","ownerDocument","unstable_useId","useId","TreeViewContext","DescendantProvider","getTreeViewUtilityClass","jsx","_jsx","useUtilityClasses","ownerState","classes","slots","root","TreeViewRoot","name","slot","overridesResolver","props","styles","padding","margin","listStyle","outline","isPrintableCharacter","string","length","match","findNextFirstChar","firstChars","startIndex","char","i","noopSelection","defaultDefaultExpanded","defaultDefaultSelected","TreeView","forwardRef","inProps","ref","children","className","defaultCollapseIcon","defaultEndIcon","defaultExpanded","defaultExpandIcon","defaultParentIcon","defaultSelected","disabledItemsFocusable","disableSelection","expanded","expandedProp","id","idProp","multiSelect","onBlur","onFocus","onKeyDown","onNodeFocus","onNodeSelect","onNodeToggle","selected","selectedProp","other","theme","isRtl","direction","treeId","treeRef","useRef","handleRef","focusedNodeId","setFocusedNodeId","useState","nodeMap","firstCharMap","setExpandedState","controlled","default","state","setSelectedState","isExpanded","useCallback","Array","isArray","indexOf","isExpandable","current","expandable","isSelected","isDisabled","node","disabled","parentId","isFocused","getChildrenIds","Object","keys","map","key","filter","sort","a","b","index","child","getNavigableChildrenIds","childrenIds","getNextNode","siblings","nextSibling","getPreviousNode","nodeIndex","currentNode","pop","getLastNode","lastNode","getFirstNode","getParent","findOrderInTremauxTree","nodeAId","nodeBId","nodeA","nodeB","aFamily","bFamily","aAncestor","bAncestor","aAncestorIsCommon","bAncestorIsCommon","continueA","continueB","push","commonAncestor","ancestorFamily","aSide","bSide","getNodesInRange","first","last","nodes","focus","event","focusNextNode","focusPreviousNode","focusFirstNode","focusLastNode","focusByFirstCharacter","start","lowercaseChar","toLowerCase","firstCharIds","forEach","nodeId","firstChar","visible","shouldBeSkipped","toggleExpansion","value","arguments","undefined","newExpanded","concat","expandAllSiblings","diff","lastSelectedNode","lastSelectionWasRange","currentRangeSelection","handleRangeArrowSelect","base","slice","next","handleRangeSelect","end","range","newSelected","handleMultipleSelect","handleSingleSelect","selectNode","multiple","selectRange","stacked","rangeSelectToFirst","rangeSelectToLast","selectNextNode","selectPreviousNode","selectAllNodes","registerNode","idAttribute","unregisterNode","newMap","oldFocusedNodeId","activeElement","mapFirstChar","unMapFirstChar","handleNextArrow","handlePreviousArrow","parent","handleKeyDown","flag","altKey","currentTarget","target","ctrlPressed","ctrlKey","metaKey","shiftKey","stopPropagation","preventDefault","handleFocus","firstSelected","handleBlur","activeDescendant","Provider","icons","role","tabIndex","process","env","NODE_ENV","propTypes","object","arrayOf","oneOfType","bool","func","sx"],"sources":["F:/Study/test_project/LinkShortener/frontend/node_modules/@mui/lab/TreeView/TreeView.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"children\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disabledItemsFocusable\", \"disableSelection\", \"expanded\", \"id\", \"multiSelect\", \"onBlur\", \"onFocus\", \"onKeyDown\", \"onNodeFocus\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"];\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport { styled, useTheme, useThemeProps } from '@mui/material/styles';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport { useControlled, useForkRef, ownerDocument, unstable_useId as useId } from '@mui/material/utils';\nimport TreeViewContext from './TreeViewContext';\nimport { DescendantProvider } from './descendants';\nimport { getTreeViewUtilityClass } from './treeViewClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getTreeViewUtilityClass, classes);\n};\nconst TreeViewRoot = styled('ul', {\n  name: 'MuiTreeView',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})({\n  padding: 0,\n  margin: 0,\n  listStyle: 'none',\n  outline: 0\n});\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction noopSelection() {\n  return false;\n}\nconst defaultDefaultExpanded = [];\nconst defaultDefaultSelected = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiTreeView'\n  });\n  const {\n      children,\n      className,\n      defaultCollapseIcon,\n      defaultEndIcon,\n      defaultExpanded = defaultDefaultExpanded,\n      defaultExpandIcon,\n      defaultParentIcon,\n      defaultSelected = defaultDefaultSelected,\n      disabledItemsFocusable = false,\n      disableSelection = false,\n      expanded: expandedProp,\n      id: idProp,\n      multiSelect = false,\n      onBlur,\n      onFocus,\n      onKeyDown,\n      onNodeFocus,\n      onNodeSelect,\n      onNodeToggle,\n      selected: selectedProp\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const theme = useTheme();\n  const isRtl = theme.direction === 'rtl';\n  const ownerState = _extends({}, props, {\n    defaultExpanded,\n    defaultSelected,\n    disabledItemsFocusable,\n    disableSelection,\n    multiSelect\n  });\n  const classes = useUtilityClasses(ownerState);\n  const treeId = useId(idProp);\n  const treeRef = React.useRef(null);\n  const handleRef = useForkRef(treeRef, ref);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const [expanded, setExpandedState] = useControlled({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = useControlled({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n\n  /*\n   * Status Helpers\n   */\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isExpandable = React.useCallback(id => nodeMap.current[id] && nodeMap.current[id].expandable, []);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n  const isDisabled = React.useCallback(id => {\n    let node = nodeMap.current[id];\n\n    // This can be called before the node has been added to the node map.\n    if (!node) {\n      return false;\n    }\n    if (node.disabled) {\n      return true;\n    }\n    while (node.parentId != null) {\n      node = nodeMap.current[node.parentId];\n      if (node.disabled) {\n        return true;\n      }\n    }\n    return false;\n  }, []);\n  const isFocused = id => focusedNodeId === id;\n\n  /*\n   * Child Helpers\n   */\n\n  // Using Object.keys -> .map to mimic Object.values we should replace with Object.values() once we stop IE11 support.\n  const getChildrenIds = id => Object.keys(nodeMap.current).map(key => {\n    return nodeMap.current[key];\n  }).filter(node => node.parentId === id).sort((a, b) => a.index - b.index).map(child => child.id);\n  const getNavigableChildrenIds = id => {\n    let childrenIds = getChildrenIds(id);\n    if (!disabledItemsFocusable) {\n      childrenIds = childrenIds.filter(node => !isDisabled(node));\n    }\n    return childrenIds;\n  };\n\n  /*\n   * Node Helpers\n   */\n\n  const getNextNode = id => {\n    // If expanded get first child\n    if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n      return getNavigableChildrenIds(id)[0];\n    }\n    let node = nodeMap.current[id];\n    while (node != null) {\n      // Try to get next sibling\n      const siblings = getNavigableChildrenIds(node.parentId);\n      const nextSibling = siblings[siblings.indexOf(node.id) + 1];\n      if (nextSibling) {\n        return nextSibling;\n      }\n\n      // If the sibling does not exist, go up a level to the parent and try again.\n      node = nodeMap.current[node.parentId];\n    }\n    return null;\n  };\n  const getPreviousNode = id => {\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nodeIndex = siblings.indexOf(id);\n    if (nodeIndex === 0) {\n      return node.parentId;\n    }\n    let currentNode = siblings[nodeIndex - 1];\n    while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {\n      currentNode = getNavigableChildrenIds(currentNode).pop();\n    }\n    return currentNode;\n  };\n  const getLastNode = () => {\n    let lastNode = getNavigableChildrenIds(null).pop();\n    while (isExpanded(lastNode)) {\n      lastNode = getNavigableChildrenIds(lastNode).pop();\n    }\n    return lastNode;\n  };\n  const getFirstNode = () => getNavigableChildrenIds(null)[0];\n  const getParent = id => nodeMap.current[id].parentId;\n\n  /**\n   * This is used to determine the start and end of a selection range so\n   * we can get the nodes between the two border nodes.\n   *\n   * It finds the nodes' common ancestor using\n   * a naive implementation of a lowest common ancestor algorithm\n   * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n   * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n   * so we can compare their indexes to work out which node comes first in a depth first search.\n   * (https://en.wikipedia.org/wiki/Depth-first_search)\n   *\n   * Another way to put it is which node is shallower in a trÃ©maux tree\n   * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n   */\n  const findOrderInTremauxTree = (nodeAId, nodeBId) => {\n    if (nodeAId === nodeBId) {\n      return [nodeAId, nodeBId];\n    }\n    const nodeA = nodeMap.current[nodeAId];\n    const nodeB = nodeMap.current[nodeBId];\n    if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n      return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n    }\n    const aFamily = [nodeA.id];\n    const bFamily = [nodeB.id];\n    let aAncestor = nodeA.parentId;\n    let bAncestor = nodeB.parentId;\n    let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n    let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n    let continueA = true;\n    let continueB = true;\n    while (!bAncestorIsCommon && !aAncestorIsCommon) {\n      if (continueA) {\n        aFamily.push(aAncestor);\n        aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        continueA = aAncestor !== null;\n        if (!aAncestorIsCommon && continueA) {\n          aAncestor = nodeMap.current[aAncestor].parentId;\n        }\n      }\n      if (continueB && !aAncestorIsCommon) {\n        bFamily.push(bAncestor);\n        bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n        continueB = bAncestor !== null;\n        if (!bAncestorIsCommon && continueB) {\n          bAncestor = nodeMap.current[bAncestor].parentId;\n        }\n      }\n    }\n    const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n    const ancestorFamily = getChildrenIds(commonAncestor);\n    const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n    const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n    return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n  };\n  const getNodesInRange = (nodeA, nodeB) => {\n    const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n    const nodes = [first];\n    let current = first;\n    while (current !== last) {\n      current = getNextNode(current);\n      nodes.push(current);\n    }\n    return nodes;\n  };\n\n  /*\n   * Focus Helpers\n   */\n\n  const focus = (event, id) => {\n    if (id) {\n      setFocusedNodeId(id);\n      if (onNodeFocus) {\n        onNodeFocus(event, id);\n      }\n    }\n  };\n  const focusNextNode = (event, id) => focus(event, getNextNode(id));\n  const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n  const focusFirstNode = event => focus(event, getFirstNode());\n  const focusLastNode = event => focus(event, getLastNode());\n  const focusByFirstCharacter = (event, id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = [];\n    // This really only works since the ids are strings\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parentId ? isExpanded(map.parentId) : true;\n      const shouldBeSkipped = disabledItemsFocusable ? false : isDisabled(nodeId);\n      if (visible && !shouldBeSkipped) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    });\n\n    // Get start index for search based on position of currentItem\n    start = firstCharIds.indexOf(id) + 1;\n    if (start >= firstCharIds.length) {\n      start = 0;\n    }\n\n    // Check remaining slots in the menu\n    index = findNextFirstChar(firstChars, start, lowercaseChar);\n\n    // If not found in remaining slots, check from beginning\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    }\n\n    // If match was found...\n    if (index > -1) {\n      focus(event, firstCharIds[index]);\n    }\n  };\n\n  /*\n   * Expansion Helpers\n   */\n\n  const toggleExpansion = (event, value = focusedNodeId) => {\n    let newExpanded;\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n    setExpandedState(newExpanded);\n  };\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const siblings = getChildrenIds(map.parentId);\n    const diff = siblings.filter(child => isExpandable(child) && !isExpanded(child));\n    const newExpanded = expanded.concat(diff);\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n\n  /*\n   * Selection Helpers\n   */\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n    if (!next || !current) {\n      return;\n    }\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n    setSelectedState(base);\n  };\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      end\n    } = nodes;\n    // If last selection was a range selection ignore nodes that were selected.\n    if (lastSelectionWasRange.current) {\n      base = base.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n    let range = getNodesInRange(start, end);\n    range = range.filter(node => !isDisabled(node));\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n    setSelectedState(newSelected);\n  };\n  const handleMultipleSelect = (event, value) => {\n    let newSelected;\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n    setSelectedState(newSelected);\n  };\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n    setSelectedState(newSelected);\n  };\n  const selectNode = (event, id, multiple = false) => {\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n    return false;\n  };\n  const selectRange = (event, nodes, stacked = false) => {\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else if (start != null && end != null) {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n    lastSelectionWasRange.current = true;\n  };\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n  const selectNextNode = (event, id) => {\n    if (!isDisabled(getNextNode(id))) {\n      selectRange(event, {\n        end: getNextNode(id),\n        current: id\n      }, true);\n    }\n  };\n  const selectPreviousNode = (event, id) => {\n    if (!isDisabled(getPreviousNode(id))) {\n      selectRange(event, {\n        end: getPreviousNode(id),\n        current: id\n      }, true);\n    }\n  };\n  const selectAllNodes = event => {\n    selectRange(event, {\n      start: getFirstNode(),\n      end: getLastNode()\n    });\n  };\n\n  /*\n   * Mapping Helpers\n   */\n  const registerNode = React.useCallback(node => {\n    const {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    } = node;\n    nodeMap.current[id] = {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    };\n  }, []);\n  const unregisterNode = React.useCallback(id => {\n    const newMap = _extends({}, nodeMap.current);\n    delete newMap[id];\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id && treeRef.current === ownerDocument(treeRef.current).activeElement) {\n        return getChildrenIds(null)[0];\n      }\n      return oldFocusedNodeId;\n    });\n  }, []);\n  const mapFirstChar = React.useCallback((id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  }, []);\n  const unMapFirstChar = React.useCallback(id => {\n    const newMap = _extends({}, firstCharMap.current);\n    delete newMap[id];\n    firstCharMap.current = newMap;\n  }, []);\n\n  /**\n   * Event handlers and Navigation\n   */\n\n  const handleNextArrow = event => {\n    if (isExpandable(focusedNodeId)) {\n      if (isExpanded(focusedNodeId)) {\n        focusNextNode(event, focusedNodeId);\n      } else if (!isDisabled(focusedNodeId)) {\n        toggleExpansion(event);\n      }\n    }\n    return true;\n  };\n  const handlePreviousArrow = event => {\n    if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n      toggleExpansion(event, focusedNodeId);\n      return true;\n    }\n    const parent = getParent(focusedNodeId);\n    if (parent) {\n      focus(event, parent);\n      return true;\n    }\n    return false;\n  };\n  const handleKeyDown = event => {\n    let flag = false;\n    const key = event.key;\n\n    // If the tree is empty there will be no focused node\n    if (event.altKey || event.currentTarget !== event.target || !focusedNodeId) {\n      return;\n    }\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n    switch (key) {\n      case ' ':\n        if (!disableSelection && !isDisabled(focusedNodeId)) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, {\n              end: focusedNodeId\n            });\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n        event.stopPropagation();\n        break;\n      case 'Enter':\n        if (!isDisabled(focusedNodeId)) {\n          if (isExpandable(focusedNodeId)) {\n            toggleExpansion(event);\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n        event.stopPropagation();\n        break;\n      case 'ArrowDown':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectNextNode(event, focusedNodeId);\n        }\n        focusNextNode(event, focusedNodeId);\n        flag = true;\n        break;\n      case 'ArrowUp':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectPreviousNode(event, focusedNodeId);\n        }\n        focusPreviousNode(event, focusedNodeId);\n        flag = true;\n        break;\n      case 'ArrowRight':\n        if (isRtl) {\n          flag = handlePreviousArrow(event);\n        } else {\n          flag = handleNextArrow(event);\n        }\n        break;\n      case 'ArrowLeft':\n        if (isRtl) {\n          flag = handleNextArrow(event);\n        } else {\n          flag = handlePreviousArrow(event);\n        }\n        break;\n      case 'Home':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToFirst(event, focusedNodeId);\n        }\n        focusFirstNode(event);\n        flag = true;\n        break;\n      case 'End':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToLast(event, focusedNodeId);\n        }\n        focusLastNode(event);\n        flag = true;\n        break;\n      default:\n        if (key === '*') {\n          expandAllSiblings(event, focusedNodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === 'a' && !disableSelection) {\n          selectAllNodes(event);\n          flag = true;\n        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {\n          focusByFirstCharacter(event, focusedNodeId, key);\n          flag = true;\n        }\n    }\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n  const handleFocus = event => {\n    // if the event bubbled (which is React specific) we don't want to steal focus\n    if (event.target === event.currentTarget) {\n      const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n      focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n    }\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n  const handleBlur = event => {\n    setFocusedNodeId(null);\n    if (onBlur) {\n      onBlur(event);\n    }\n  };\n  const activeDescendant = nodeMap.current[focusedNodeId] ? nodeMap.current[focusedNodeId].idAttribute : null;\n  return /*#__PURE__*/_jsx(TreeViewContext.Provider, {\n    // TODO: fix this lint error\n    // eslint-disable-next-line react/jsx-no-constructed-context-values\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      toggleExpansion,\n      isExpanded,\n      isExpandable,\n      isFocused,\n      isSelected,\n      isDisabled,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      multiSelect,\n      disabledItemsFocusable,\n      mapFirstChar,\n      unMapFirstChar,\n      registerNode,\n      unregisterNode,\n      treeId\n    },\n    children: /*#__PURE__*/_jsx(DescendantProvider, {\n      children: /*#__PURE__*/_jsx(TreeViewRoot, _extends({\n        role: \"tree\",\n        id: treeId,\n        \"aria-activedescendant\": activeDescendant,\n        \"aria-multiselectable\": multiSelect,\n        className: clsx(classes.root, className),\n        ref: handleRef,\n        tabIndex: 0,\n        onKeyDown: handleKeyDown,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        ownerState: ownerState\n      }, other, {\n        children: children\n      }))\n    })\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? TreeView.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The default icon used to collapse the node.\n   */\n  defaultCollapseIcon: PropTypes.node,\n  /**\n   * The default icon displayed next to a end node. This is applied to all\n   * tree nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultEndIcon: PropTypes.node,\n  /**\n   * Expanded node ids. (Uncontrolled)\n   * @default []\n   */\n  defaultExpanded: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * The default icon used to expand the node.\n   */\n  defaultExpandIcon: PropTypes.node,\n  /**\n   * The default icon displayed next to a parent node. This is applied to all\n   * parent nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultParentIcon: PropTypes.node,\n  /**\n   * Selected node ids. (Uncontrolled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: PropTypes.bool,\n  /**\n   * If `true` selection is disabled.\n   * @default false\n   */\n  disableSelection: PropTypes.bool,\n  /**\n   * Expanded node ids. (Controlled)\n   */\n  expanded: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: PropTypes.string,\n  /**\n   * If true `ctrl` and `shift` will trigger multiselect.\n   * @default false\n   */\n  multiSelect: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onFocus: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n  /**\n   * Callback fired when tree items are focused.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback **Warning**: This is a generic event not a focus event.\n   * @param {string} value of the focused node.\n   */\n  onNodeFocus: PropTypes.func,\n  /**\n   * Callback fired when tree items are selected/unselected.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback\n   * @param {string[] | string} nodeIds Ids of the selected nodes. When `multiSelect` is true\n   * this is an array of strings; when false (default) a string.\n   */\n  onNodeSelect: PropTypes.func,\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes.\n   */\n  onNodeToggle: PropTypes.func,\n  /**\n   * Selected node ids. (Controlled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default TreeView;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}